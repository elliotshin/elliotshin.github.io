---
layout: post
title: Blog Post 3
---

## Introduction
Hello! Today we will be learning how to set up a web app using the flask package in python! For starters, it is important to create a folder for the project we will be running today!

After you have set up your folder and have navigated to it within your command prompt, you are going to need to run the following commands in your command prompt to set up your flask project:
 **conda activate pic16B**
 **export FLASK_ENV=development** (only have to run this once)
 **flask run**(will have to run this everytime you create a new session)

 Great! Now that that is all settled, let's start developing.

## HTML Design
Prior to the backend development of the app, we should first discuss how to create templates. These are HTML documents created that will allow us to give the user an interface to interact with. These will also incoprorate Jinja tags to allow for interactions with python code! 

# Main.html
```html
{% raw %}
{% extends 'base.html' %}

{% block header %}
	<h1>Welcome to this webpage! Click one of  the above links to get started!</h1>
{% endblock %}
-


{% endraw %}

```

Let's examine our most simple example, the main.html template.
The {} are our jinja tags, these allow for python interactivity. This is just a simple example, but we are doing this to demonstrate the difference between the jinja tags, and the html tags, which are denoted as <>. Let's look at what we have created! 

![mainpage](/images/mainpage.png)

As you can see, the 'h1' tag in the above code is responsible for the header of the page! That is because h1 stands for 'header 1'

# View.html 
Next we are going to examine the view.html template, or what the user will see when they choose to view messages submitted by other users!

```html
{% raw %}
{% extends 'base.html' %}

{% block header %}
	<h1>{% block title %}Message Viewer{% endblock %}</h1> 	
{% endblock %}

{% block content %}
	{% for message in messages %}
		<br><br>{{message[0]}}: {{message[1]}}, {{message[2]}}
	{% endfor %}
{% endblock %} 


{% endraw %}

```
In this example, the jinja tags are more complex, so let's break it down! 
First you will notice the jinja tags that extend 'base.html'. These are used to extend our base.template, in which our navigation menu is stored. 
The biggest thing of note for the jinja tags here is the use of a for loop that prints variables passed to it. As you can see, the jinja syntax for for loops is quite similar to the python syntax. Seeing as the template is called "view", you are correct in assuming that the for loop will be what enables viewing of the submissions! The message[0],message[1], and message[3] are the components of the data that is being sent to the template. But how does the data get sent to the template?

# WebApp

## The Big Picture
Before we get into details of our code, lets look at what it will look like at the end! 
```python
from flask import Flask, render_template, request, Blueprint, g, url_for, abort
import sqlite3 
 

def get_message_db():
	"""This function checks whether there is a database called message_db in the g attribute of the app. 
	If not, then connect to that database, ensuring that the connection is an attribute of g"""
	if 'message_db' not in g:
		g.message_db = sqlite3.connect('messages.sqlite') #connection established

		#query to create sqlite table
		messages_table_query = """ CREATE TABLE IF NOT EXISTS messages (
			id INTEGER,
			handle TEXT NOT NULL,
			message TEXT NOT NULL
		); """
		c = g.message_db.cursor()
		#creates sqlite table
		c.execute(messages_table_query)
		print("sqlite3 connected")
	return g.message_db

def close_message_db(e = None):
	"""This method breaks the connection to the database and closes it"""
	db = g.pop('message_db', None) #popping the element releases the connection, if no database, return none 

	if db is not None:
		print("sqlite3 closed")
		db.close()


def insert_message(request):
	"""
	Extracts the message and the handle from request. 
	inserts the message into the message database
	"""
	handle = request.form['handle']
	usermessage = request.form['usermessage']
	print(handle,usermessage)
	db = get_message_db()
	c = db.cursor()
	x = c.execute('SELECT COUNT(*) AS rows FROM messages') 
	test = x.fetchone()
	print(test)
	print(type(test))
	(ID,) = test
	ID = ID + 1
	print(ID)
	insert_query = """INSERT OR IGNORE INTO messages (id,handle, message) VALUES (?,?,?)"""
	val = (ID, handle, usermessage)
	c.execute(insert_query,val)  
	print("executed order 66")
	db.commit()
	print("db committed")
	print("finished insert_message method")

def random_messages(n):
	"""
	returns a collection of n random messages from the message_db, or fewer if necessary
	"""
	db = get_message_db();
	c = db.cursor();
	rows = c.execute('SELECT id FROM messages').fetchall()[-1]
	(rows,) = rows
	print(n,rows)
	if (rows < n):
		n = rows
		rando_query = """SELECT * FROM messages ORDER BY RANDOM() LIMIT ? """
		c.execute(rando_query,(n,))
	else:
		rando_query = """SELECT * FROM messages ORDER BY RANDOM() LIMIT ? """
		c.execute(rando_query,(n,))
	return c
app = Flask(__name__) 

@app.route("/")
def main():
	return render_template("main.html")
#controls what url the page you develop will have
#root directory

@app.route("/submit/", methods = ["POST", "GET"])
def submit():
	if request.method == "GET":
		return render_template("submit.html")
	if request.method == "POST":
		insert_message(request)
		print("message inserted") 
		return render_template("submit.html", handle = request.form["handle"], usermessage = request.form["usermessage"], thanks = True) 

@app.route("/view/")
def view():
	db = get_message_db()
	rand_messages = random_messages(5)
	messages = rand_messages.fetchall()
	return render_template('view.html', messages = messages) 
	



app.teardown_appcontext(close_message_db)

```
It is quite a lot to behold! But let's break it down now

### The get_message_db() function
The get_message_db() function is designed to do two things: First, it checks to make sure that there is a database present in our global object, g. 

```python
def get_message_db():
	"""This function checks whether there is a database called message_db in the g attribute of the app. 
	If not, then connect to that database, ensuring that the connection is an attribute of g"""
	if 'message_db' not in g:
		g.message_db = sqlite3.connect('messages.sqlite') #connection established

		#query to create sqlite table
		messages_table_query = """ CREATE TABLE IF NOT EXISTS messages (
			id INTEGER,
			handle TEXT NOT NULL,
			message TEXT NOT NULL
		); """
		c = g.message_db.cursor()
		#creates sqlite table
		c.execute(messages_table_query)
		print("sqlite3 connected")
	return g.message_db


```